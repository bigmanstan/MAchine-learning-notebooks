# -*- coding: utf-8 -*-
"""internshala.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nuc1FM8gTbzSjdIIAW8JTQOx36UfU6Fp
"""



"""# **Problem statement:**

Given an N by N chessboard, with a black pawn and a white pawn placed randomly on the board, calculate the minimum number of steps required for the white pawn to reach the black pawn under the following assumptions:

a. There are only two pieces on the chessboard.

b. The pieces can move in all 8 directions, one step at a time.
"""

#applying standard BSF


def path(p):
	global n
	r=[]
	x,y=p
	if x-1>-1 :
		r.append((x-1,y))
	if x+1<n :
		r.append((x+1,y))
	if y-1>-1 :
		r.append((x,y-1))
	if y+1<n :
		r.append((x,y+1))
	if x+1<n and y+1<n:
	    r.append((x+1,y+1))
	if x-1>-1 and y-1>-1:
	    r.append((x-1,y-1))
	if x+1<n and y-1>-1:
	    r.append((x+1,y-1))
	if x-1>-1 and y+1 < n:
	    r.append((x-1,y+1))
	return(r)
n = int(input("Enter number of Rows 'N' in your NxN chess board : ")) 
 
 
def bfs(s):
    level={s:0}
    i=1
    frontier=[s]
    while frontier:
        nex=[]
        for u in frontier:
            for v in path(u):
                if v not in level:
                	level[v]=i
                	nex.append(v)
        frontier=nex
        i+=1
    return(level)
 


s=[int(i) for i in input("Enter space seperated coordinates of black pawn e.g '7 1'  : ").split(' ')]
s=[i-1 for i in s]
s=tuple(s)
r=bfs(s)

d=[int(i) for i in input("Enter space seperated coordinates of white pawn e.g '5 3'  : ").split(' ')]
d=[i-1 for i in d]
d=tuple(d)
try:
	print("It'll take ",r[d]," moves")
except:
	print("there was an error in input")

8